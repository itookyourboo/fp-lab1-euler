# Лабораторная работа №1

## Цель работы
Освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы предлагается решить несколько задач [проекта Эйлер](https://projecteuler.net/archives).

## Вариант

12. Highly Divisible Triangular Number
19. Counting Sundays

## 12. Highly Divisible Triangular Number

### Условие

The sequence of triangle numbers is generated by adding the natural numbers. So the 
7-th triangle number would be `1 + 2 + 3 + 4 + 5 + 6 + 7 = 28`. The first ten terms would be:

`1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...`

Let us list the factors of the first seven triangle numbers:

```
1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
```


We can see that `28` is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

### Решение

**Примечание**. Треугольное число представляется в виде `n * (n + 1) // 2`.

Я намеренно не использовал эту формулу, чтобы немного усложнить себе жизнь.

#### Реализация на Python

Сперва рассмотрим реализацию на традиционном языке, чтобы было представление об используемом ниже алгоритме.

```python
def count_divisors(n: int) -> int:
    if n == 1:
        return 1

    result: int = 2
    for divisor in range(2, int(n ** .5) + 1):
        if n % divisor != 0:
            continue

        if n // divisor == divisor:
            result += 1
        else:
            result += 2

    return result


def find_triangle_with_divisors(divisor_count: int) -> int:
    n, triangle = 1, 0
    while True:
        triangle += n
        if count_divisors(triangle) > divisor_count:
            return triangle
        n += 1


divisor_count = 500
result = find_triangle_with_divisors(divisor_count)
print(f"The first triangle number with over {divisor_count} divisors is {result}")
```

#### Хвостовая рекурсия

```elixir
defmodule TriangleNumber do
  defp _count_divisors(n, divisor, count) when divisor * divisor > n do
    count
  end
  defp _count_divisors(n, divisor, count) when rem(n, divisor) != 0 do
    _count_divisors(n, divisor + 1, count)
  end
  defp _count_divisors(n, divisor, count) when div(n, divisor) == divisor do
    _count_divisors(n, divisor + 1, count + 1)
  end
  defp _count_divisors(n, divisor, count) do
    _count_divisors(n, divisor + 1, count + 2)
  end

  def count_divisors(n) do
    _count_divisors(n, 1, 0)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
end

divisor_count = 500
result = TriangleNumber.find_triangle_with_divisors(divisor_count)
IO.puts("The first triangle number with over #{divisor_count} divisors is #{result}")
```

#### Обычная рекурсия

Здесь меняется только функция `count_divisors`. Не придумал, как можно с помощью обычной рекурсии сделать генерацию последовательности треугольных чисел.

```elixir
defmodule TriangleNumber do
  defp _count_divisors(n, divisor) when divisor * divisor > n do
    1
  end
  defp _count_divisors(n, divisor) when rem(n, divisor) != 0 do
    _count_divisors(n, divisor + 1)
  end
  defp _count_divisors(n, divisor) when div(n, divisor) == divisor do
    1 + _count_divisors(n, divisor + 1)
  end
  defp _count_divisors(n, divisor) do
    2 + _count_divisors(n, divisor + 1)
  end
  defp count_divisors(n) do
    _count_divisors(n, 1)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
end

divisor_count = 500
result = TriangleNumber.find_triangle_with_divisors(divisor_count)
IO.puts("The first triangle number with over #{divisor_count} divisors is #{result}")
```

#### Модульная реализация

Здесь выделены следующие модули:

1. Генерация последовательности делителей числа X
2. Подсчет количества делителей в последовательности с помощью `Enum.count`
3. Получение n-ного треугольного числа с помощью `Enum.reduce`

```elixir
defmodule TriangleNumber do
  defp divisors(1), do: [1]
  defp divisors(n), do: [1, n | divisors(2, n, n)]
  defp divisors(k, _n, q) when k * k > q, do: []
  defp divisors(k, n, q) when rem(n, k) != 0 do
    divisors(k + 1, n, q)
  end
  defp divisors(k, n, q) when k * k == n do
    [k | divisors(k + 1, n, q)]
  end
  defp divisors(k, n, q) do
    [k, div(n, k) | divisors(k + 1, n, q)]
  end

  defp count_divisors(n) do
    n
    |> divisors
    |> Enum.count
  end

  defp triangle_number(n) do
    Enum.reduce(1..n, 0, fn x, acc -> x + acc end)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1) do
    if count_divisors(triangle_number(n)) > divisor_count do
      triangle_number(n)
    else
      find_triangle_with_divisors(divisor_count, n + 1)
    end
  end
end

divisor_count = 500
result = TriangleNumber.find_triangle_with_divisors(divisor_count)
IO.puts("The first triangle number with over #{divisor_count} divisors is #{result}")
```

#### Генерация последовательности при помощи отображения / работа с бесконечными списками

```elixir
defmodule TriangleNumber do
  defp divisors(1), do: [1]
  defp divisors(n), do: [1, n | divisors(2, n, n)]
  defp divisors(k, _n, q) when k * k > q, do: []
  defp divisors(k, n, q) when rem(n, k) != 0 do
    divisors(k + 1, n, q)
  end
  defp divisors(k, n, q) when k * k == n do
    [k | divisors(k + 1, n, q)]
  end
  defp divisors(k, n, q) do
    [k, div(n, k) | divisors(k + 1, n, q)]
  end

  defp count_divisors(n) do
    n
    |> divisors
    |> Enum.count
  end

  defp triangles do
    {0, 1}
    |> Stream.iterate(fn {cur, n} -> {cur + n, n + 1} end)
    |> Stream.map(fn {triangle, _} -> triangle end)
  end

  def find_triangle_with_divisors(divisor_count) do
    triangles()
    |> Stream.map(fn triangle -> {triangle, count_divisors(triangle)} end)
    |> Stream.filter(fn {_triangle, divisors} -> divisors > divisor_count end)
    |> Enum.take(1)
    |> Enum.at(0)
    |> elem(0)
  end
end

divisor_count = 500
result = TriangleNumber.find_triangle_with_divisors(divisor_count)
IO.puts("The first triangle number with over #{divisor_count} divisors is #{result}")
```

## 19. Counting Sundays

### Условие

You are given the following information, but you may prefer to do some research for yourself.

- 1 Jan 1900 was a Monday.
- Thirty days has September, April, June and November.
- All the rest have thirty-one
- Saving February alone, Which has twenty-eight, rain or shine. And on leap years, twenty-nine.
- A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.

How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

### Решение

#### Реализация на Python

```python
def is_leap_year(year: int) -> bool:
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        return True
    return False


def days_in_month(month: int, year: int) -> int:
    if month in (4, 6, 9, 11):  # April, June, September, November
        return 30

    if month == 2:  # February
        return 29 if is_leap_year(year) else 28

    return 31


def count_sundays_of_first_of_month():
    count = 0
    day = 2  # 1 Jan 1901 was a Tuesday

    for year in range(1901, 2001):
        for month in range(1, 13):
            if day == 0:  # Sunday
                count += 1
            day = (day + days_in_month(month, year)) % 7

    return count


result = count_sundays_of_first_of_month()
print(f"Number of Sundays on the first of the month during the twentieth century: {result}")
```

#### Хвостовая рекурсия

```elixir
defmodule SundaysOnFirst do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) when is_leap_year(year), do: 29
  defp days_in_month(2, _), do: 28
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  defp count_sundays_on_first_of_month(start_year, end_year, day, count) when start_year > end_year, do: count
  defp count_sundays_on_first_of_month(start_year, end_year, day, count) do
    {year, month, _} = {start_year, 1, day}
    next_day = (day + days_in_month(month, year)) rem 7
    next_year = if month == 12, do: year + 1, else: year

    count_sundays_on_first_of_month(
      next_year,
      end_year,
      next_day,
      count + if day == 0, do: 1, else: 0
    )
  end

  def count_sundays_on_first_of_month(start_year, end_year) do
    count_sundays_on_first_of_month(start_year, end_year, 2, 0)
  end

  def main do
    result = count_sundays_on_first_of_month(1901, 2000)
    IO.puts("Number of Sundays on the first of the month during the twentieth century: #{result}")
  end
end

SundaysOnFirst.main()
```

#### Модульная реализация

```elixir
defmodule SundaysOnFirst do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) when is_leap_year(year), do: 29
  defp days_in_month(2, _), do: 28
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  defp first_sundays(year, day) do
    for month <- 1..12, day == 0, do: 1
    day = (day + days_in_month(month, year)) rem 7
  end

  defp count_sundays_on_first_of_month(start_year, end_year) do
    1..(end_year - start_year + 1)
    |> Enum.reduce(0, fn year, acc ->
      first_sundays(year, acc)
    end)
  end

  def main do
    result = count_sundays_on_first_of_month(1901, 2000)
    IO.puts("Number of Sundays on the first of the month during the twentieth century: #{result}")
  end
end

SundaysOnFirst.main()
```

#### Генерация последовательности при помощи отображения

```elixir
defmodule SundaysOnFirst do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) when is_leap_year(year), do: 29
  defp days_in_month(2, _), do: 28
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  defp first_sundays(year, day) do
    1..12
    |> Enum.map(&if day == 0, do: 1, else: 0)
    |> Enum.reduce(day, fn d, acc ->
      day = (acc + days_in_month(1, year)) rem 7
      d + if day == 0, do: 1, else: 0
    end)
  end

  defp count_sundays_on_first_of_month(start_year, end_year) do
    1..(end_year - start_year + 1)
    |> Enum.map(fn year ->
      first_sundays(year, 2)  # 1 Jan 1901 was a Tuesday (0=Sunday, 1=Monday, 2=Tuesday, ...)
    end)
    |> Enum.sum()
  end

  def main do
    result = count_sundays_on_first_of_month(1901, 2000)
    IO.puts("Number of Sundays on the first of the month during the twentieth century: #{result}")
  end
end

SundaysOnFirst.main()
```

#### Работа с бесконечными списками

```elixir
defmodule SundaysOnFirst do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) when is_leap_year(year), do: 29
  defp days_in_month(2, _), do: 28
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  def count_sundays_on_first_of_month(start_year, end_year) do
    Stream.iterate({1901, 1, 2}, fn {year, month, day} ->
      next_month = if month == 12, do: 1, else: month + 1
      next_year = if month == 12, do: year + 1, else: year
      {next_year, next_month, (day + days_in_month(month, year)) rem 7}
    end)
    |> Stream.drop(start_year - 1901)
    |> Stream.take(end_year - start_year + 1)
    |> Stream.filter(fn {_, _, day} -> day == 0 end)
    |> Enum.count()
  end

  def main do
    result = count_sundays_on_first_of_month(1901, 2000)
    IO.puts("Number of Sundays on the first of the month during the twentieth century: #{result}")
  end
end

SundaysOnFirst.main()
```

## Выводы

В ходе выполнения я познакомился с синтаксисом Elixir. Для меня функциональное программирование в новинку, поэтому лабораторная заставила поломать мозги. От этого было интересно.
