# Лабораторная работа №1

## Цель работы
Освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы предлагается решить несколько задач [проекта Эйлер](https://projecteuler.net/archives).

## Вариант

12. Highly Divisible Triangular Number
19. Counting Sundays

## 12. Highly Divisible Triangular Number

### Условие

The sequence of triangle numbers is generated by adding the natural numbers. So the 
7-th triangle number would be `1 + 2 + 3 + 4 + 5 + 6 + 7 = 28`. The first ten terms would be:

`1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...`

Let us list the factors of the first seven triangle numbers:

```
1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
```


We can see that `28` is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

### Решение

**Примечание**. Треугольное число представляется в виде `n * (n + 1) // 2`.

Я намеренно не использовал эту формулу, чтобы немного усложнить себе жизнь.

#### Реализация на Python

Сперва рассмотрим реализацию на традиционном языке, чтобы было представление об используемом ниже алгоритме.

```python
def count_divisors(n: int) -> int:
    if n == 1:
        return 1

    result: int = 2
    for divisor in range(2, int(n ** .5) + 1):
        if n % divisor != 0:
            continue

        if n // divisor == divisor:
            result += 1
        else:
            result += 2

    return result


def find_triangle_with_divisors(divisor_count: int) -> int:
    n, triangle = 1, 0
    while True:
        triangle += n
        if count_divisors(triangle) > divisor_count:
            return triangle
        n += 1


divisor_count = 500
result = find_triangle_with_divisors(divisor_count)
print(f"The first triangle number with over {divisor_count} divisors is {result}")
```

#### Хвостовая рекурсия

```elixir
defmodule TriangleNumberTailRecursion do
  defp _count_divisors(n, divisor, count) when divisor * divisor > n do
    count
  end
  defp _count_divisors(n, divisor, count) when rem(n, divisor) != 0 do
    _count_divisors(n, divisor + 1, count)
  end
  defp _count_divisors(n, divisor, count) when div(n, divisor) == divisor do
    _count_divisors(n, divisor + 1, count + 1)
  end
  defp _count_divisors(n, divisor, count) do
    _count_divisors(n, divisor + 1, count + 2)
  end

  def count_divisors(n) do
    _count_divisors(n, 1, 0)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
end
```

#### Обычная рекурсия

Здесь меняется только функция `count_divisors`. Не придумал, как можно с помощью обычной рекурсии сделать генерацию последовательности треугольных чисел.

```elixir
defmodule TriangleNumberRecursion do
  defp _count_divisors(n, divisor) when divisor * divisor > n do
    1
  end
  defp _count_divisors(n, divisor) when rem(n, divisor) != 0 do
    _count_divisors(n, divisor + 1)
  end
  defp _count_divisors(n, divisor) when divisor * divisor == n do
    1 + _count_divisors(n, divisor + 1)
  end
  defp _count_divisors(n, divisor) do
    2 + _count_divisors(n, divisor + 1)
  end
  def count_divisors(n) do
    _count_divisors(n, 1)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
end
```

#### Модульная реализация

Здесь выделены следующие модули:

1. Генерация последовательности делителей числа X
2. Подсчет количества делителей в последовательности с помощью `Enum.count`
3. Получение n-ного треугольного числа с помощью `Enum.reduce`

```elixir
defmodule TriangleNumberGFR do
  defp divisors(1), do: [1]
  defp divisors(n), do: [1, n | divisors(2, n, n)]
  defp divisors(k, _n, q) when k * k > q, do: []
  defp divisors(k, n, q) when rem(n, k) != 0 do
    divisors(k + 1, n, q)
  end
  defp divisors(k, n, q) when k * k == n do
    [k | divisors(k + 1, n, q)]
  end
  defp divisors(k, n, q) do
    [k, div(n, k) | divisors(k + 1, n, q)]
  end

  defp count_divisors(n) do
    n
    |> divisors
    |> Enum.count
  end

  defp triangle_number(n) do
    Enum.reduce(1..n, 0, fn x, acc -> x + acc end)
  end

  def find_triangle_with_divisors(divisor_count, n \\ 1) do
    if count_divisors(triangle_number(n)) > divisor_count do
      triangle_number(n)
    else
      find_triangle_with_divisors(divisor_count, n + 1)
    end
  end
end
```

#### Генерация последовательности при помощи отображения / работа с бесконечными списками

```elixir
defmodule TriangleNumberMap do
  defp divisors(1), do: [1]
  defp divisors(n), do: [1, n | divisors(2, n, n)]
  defp divisors(k, _n, q) when k * k > q, do: []
  defp divisors(k, n, q) when rem(n, k) != 0 do
    divisors(k + 1, n, q)
  end
  defp divisors(k, n, q) when k * k == n do
    [k | divisors(k + 1, n, q)]
  end
  defp divisors(k, n, q) do
    [k, div(n, k) | divisors(k + 1, n, q)]
  end

  defp count_divisors(n) do
    n
    |> divisors
    |> Enum.count
  end

  defp triangles do
    {0, 1}
    |> Stream.iterate(fn {cur, n} -> {cur + n, n + 1} end)
    |> Stream.map(fn {triangle, _} -> triangle end)
  end

  def find_triangle_with_divisors(divisor_count) do
    triangles()
    |> Stream.map(fn triangle -> {triangle, count_divisors(triangle)} end)
    |> Stream.filter(fn {_triangle, divisors} -> divisors > divisor_count end)
    |> Enum.take(1)
    |> Enum.at(0)
    |> elem(0)
  end
end
```

### Тестирование

Тестирование проводилось с помощью модуля ExUnit.

```elixir
defmodule TestTriangleNumberTailRecursion do
  use ExUnit.Case

  @module TriangleNumberTailRecursion

  test "5 divisors" do
    {arg, expected} = {5, 28}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end

  test "10 divisors" do
    {arg, expected} = {10, 120}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end

  test "50 divisors" do
    {arg, expected} = {50, 25_200}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end

  test "100 divisors" do
    {arg, expected} = {100, 73_920}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end

  test "200 divisors" do
    {arg, expected} = {200, 2_031_120}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end

  test "500 divisors" do
    {arg, expected} = {500, 76_576_500}
    real = @module.find_triangle_with_divisors(arg)
    assert real == expected
  end
end
```

## 19. Counting Sundays

### Условие

You are given the following information, but you may prefer to do some research for yourself.

- 1 Jan 1900 was a Monday.
- Thirty days has September, April, June and November.
- All the rest have thirty-one
- Saving February alone, Which has twenty-eight, rain or shine. And on leap years, twenty-nine.
- A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.

How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

### Решение

#### Реализация на Python

```python
def is_leap_year(year: int) -> bool:
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        return True
    return False


def days_in_month(month: int, year: int) -> int:
    if month in (4, 6, 9, 11):  # April, June, September, November
        return 30

    if month == 2:  # February
        return 29 if is_leap_year(year) else 28

    return 31


def count_sundays_of_first_of_month():
    count = 0
    day = 2  # 1 Jan 1901 was a Tuesday

    for year in range(1901, 2001):
        for month in range(1, 13):
            if day == 0:  # Sunday
                count += 1
            day = (day + days_in_month(month, year)) % 7

    return count


result = count_sundays_of_first_of_month()
print(f"Number of Sundays on the first of the month during the twentieth century: {result}")
```

#### Хвостовая рекурсия

```elixir
defmodule SundaysOnFirstTailRecursion do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) do
    if is_leap_year(year), do: 29, else: 28
  end
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  defp count_sundays_on_first_of_month(start_year, end_year, _month, _day, count) when start_year > end_year, do: count
  defp count_sundays_on_first_of_month(start_year, end_year, month, day, count) do
    year = start_year
    next_day = rem(day + days_in_month(month, year), 7)
    next_year = if month == 12, do: year + 1, else: year
    next_month = if month == 12, do: 1, else: month + 1

    count_sundays_on_first_of_month(
      next_year,
      end_year,
      next_month,
      next_day,
      count + (if day == 0, do: 1, else: 0)
    )
  end

  def count_sundays_on_first_of_month(start_year, end_year, jan1) do
    count_sundays_on_first_of_month(start_year, end_year, 1, jan1, 0)
  end
end
```

#### Модульная реализация

```elixir
defmodule SundaysOnFirstGFR do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) do
    if is_leap_year(year), do: 29, else: 28
  end
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  defp iter_weekday(w), do: rem(w + 1, 7)
  defp iter_day(d, m, y) do
    if d == days_in_month(m, y), do: 1, else: d + 1
  end

  defp iter_month(d, m, y) do
    if iter_day(d, m, y) == 1 do
      if m == 12, do: 1, else: m + 1
    else
      m
    end
  end

  defp iter_year(d, m, y) do
    if m == 12 && iter_day(d, m, y) == 1, do: y + 1, else: y
  end

  defp gen_days(start_year, month, day, weekday) do
    Stream.iterate({start_year, month, day, weekday}, fn {y, m, d, w} ->
      {iter_year(d, m, y), iter_month(d, m, y), iter_day(d, m, y), iter_weekday(w)}
    end)
  end

  defp filter_years(seq, end_year) do
    Enum.take_while(
      seq,
      fn {year, _, _, _} -> year <= end_year
    end)
  end

  defp filter_days(seq) do
    Enum.filter(seq,
      fn {_, _, day, weekday} -> day == 1 && weekday == 0
    end)
  end

  defp count(seq) do
    Enum.count(seq)
  end

  def count_sundays_on_first_of_month(start_year, end_year, jan1) do
    gen_days(start_year, 1, 1, jan1)
    |> filter_years(end_year)
    |> filter_days
    |> count
  end
end
```

#### Работа с бесконечными списками

```elixir
defmodule SundaysOnFirstStreams do
  defp is_leap_year(year) when rem(year, 400) == 0, do: true
  defp is_leap_year(year) when rem(year, 100) == 0, do: false
  defp is_leap_year(year) when rem(year, 4) == 0, do: true
  defp is_leap_year(_), do: false

  defp days_in_month(2, year) do
    if is_leap_year(year), do: 29, else: 28
  end
  defp days_in_month(month, _)
      when month in [4, 6, 9, 11], do: 30
  defp days_in_month(_, _), do: 31

  def count_sundays_on_first_of_month(start_year, end_year, jan1) do
    Stream.iterate({start_year, 1, jan1}, fn {year, month, day} ->
      next_day = rem(day + days_in_month(month, year), 7)
      next_month = if month == 12, do: 1, else: month + 1
      next_year = if month == 12, do: year + 1, else: year
      {next_year, next_month, next_day}
    end)
    |> Stream.take_while(fn {year, _, _} -> year <= end_year end)
    |> Stream.filter(fn {_, _, day} -> day == 0 end)
    |> Enum.count()
  end
end
```

### Тестирование

Тестирование проводилось с помощью модуля ExUnit.

```elixir
defmodule TestSundaysOnFirstTailRecursion do
  use ExUnit.Case

  @module SundaysOnFirstTailRecursion

  test "From 1901 to 2000" do
    {from, to, jan1, expected} = {1901, 2000, 2, 171}
    real = @module.count_sundays_on_first_of_month(from, to, jan1)
    assert real == expected
  end
end
```

## Дополнительное задание (Dialyzer)

Dialyzer - это инструмент статической анализа кода для языка программирования Elixir.

### Установка

1. Добавляем зависимость в `mix.exs`:
    ```elixir
    {:dialyxir, "~> 1.3", only: [:dev], runtime: false}
    ```
2. Устанавливаем `erlang-dialyzer`:
    ```shell
    sudo apt install erlang-dialyzer
    ```

### Использование

1. Подтягиваем зависимость:
    ```shell
   mix do deps.get, deps.compile
    ```
2. Запускаем:
    ```
    mix dialyzer
    ```

### Пример работы

```elixir
  @spec count_divisors(integer()) :: integer()
  def count_divisors(n) do
    _count_divisors(n, 1, 0)
  end

  @spec find_triangle_with_divisors(integer(), integer(), integer()) :: integer()
  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
```

```shell
Total errors: 0, Skipped: 0, Unnecessary Skips: 0
done in 0m0.76s
done (passed successfully)
```

А теперь поменяем в `count_divisors` тип аргумента с `integer` на `String.t`:

```elixir
  @spec count_divisors(String.t()) :: integer()
  def count_divisors(n) do
    _count_divisors(n, 1, 0)
  end

  @spec find_triangle_with_divisors(integer(), integer(), integer()) :: integer()
  def find_triangle_with_divisors(divisor_count, n \\ 1, sum \\ 0) do
    if count_divisors(sum) > divisor_count do
      sum
    else
      find_triangle_with_divisors(divisor_count, n + 1, sum + n)
    end
  end
```

```shell
lib/task12/tail_recursion.ex:20:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
TriangleNumberTailRecursion.find_triangle_with_divisors/3

Success typing:
@spec find_triangle_with_divisors(_, _, binary()) :: binary()

________________________________________________________________________________
lib/task12/tail_recursion.ex:21:no_return
Function find_triangle_with_divisors/1 has no local return.
________________________________________________________________________________
lib/task12/tail_recursion.ex:21:no_return
Function find_triangle_with_divisors/2 has no local return.
________________________________________________________________________________
lib/task12/tail_recursion.ex:25:call
The function call will not succeed.

:erlang.+(_sum :: binary(), _n :: number())

will never return since the 1st arguments differ
from the success typing arguments:

(number(), number())

________________________________________________________________________________
done (warnings were emitted)
Halting VM with exit status 2
```

## Выводы

В ходе выполнения я познакомился с синтаксисом Elixir. Для меня функциональное программирование в новинку, поэтому лабораторная заставила поломать мозги. От этого было интересно.

Функциональное программирование стимулирует к написанию чистого кода. Маленькие функции очень просто дебажить.

Еще понравилась концепция подачи выхода одной функции на вход другой. Так код становится довольно лаконичным.
